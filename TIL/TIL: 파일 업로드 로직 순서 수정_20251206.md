# TIL - 파일 업로드 로직 순서 수정

## 1. 기존 업로드 흐름

1. 클라이언트가 파일 업로드 요청을 보낸다.
2. 서버가 파일을 스토리지에 업로드한다
3. 업로드가 성공하면 서버가 DB에 파일 메타데이터를 저장한다.

## 2. 기존 구조의 문제점

### 2-1. 스토리지 고아 파일(orphan object) 발생 가능성

아래 시나리오에서 문제가 발생한다.

- 스토리지 업로드는 성공했지만
- 그 직후 실행되는 **DB 메타데이터 저장이 실패한 경우**

이때:

- 스토리지에는 파일이 남아 있고
- DB에는 해당 파일 정보가 없음

→ 스토리지에만 존재하는 고아 파일이 발생하게 된다.
→ 별도 정리 작업(clean-up) 없이는 운영 비용과 장애 위험이 증가한다.

### 2-2. 데이터 일관성(Consistency) 문제

“파일이 존재한다”의 기준은 사실상 다음 두 조건을 모두 충족해야 한다.

- DB(FileMetadata)에 존재
- 실제 스토리지에도 존재

기존 순서(스토리지 → DB)에서는 이 일관성을 보장하기 어렵다.

### 2-3. 장애 분석 및 운영 관리 난이도 증가

스토리지와 DB가 서로 다른 상태가 될 수 있으므로:

- 어떤 파일이 실제로 서비스에서 사용되는지 판단하기 어렵고
- 로그와 데이터를 여러 시스템에서 교차 확인해야 함

## 2. 문제점

1. 고아(orphan) 파일 발생 가능성
   - 스토리지 업로드는 성공했지만 DB 메타데이터 저장이 실패하는 상황이 발생할 수 있다.
   - 이 경우 스토리지에만 덩그러니 남는 파일이 생긴다.

## 3. 개선된 파일 업로드 흐름

문제를 해결하기 위해 업로드 순서를 다음과 같이 변경했다.

1. 클라이언트가 파일 업로드 요청을 보낸다.
2. 서버가 DB에 파일 메타데이터를 저장한다. (상태: UPLOADING)
3. 서버가 파일을 스토리지에 업로드한다.
4. 업로드가 성공하면 서버가 DB 메타데이터를 업데이트한다. (상태: TEMP)
5. 업로드가 실패하면 서버가 DB 메타데이터를 삭제하거나 상태를 FAILED로 변경한다. - (보상 로직 필요)

- 파일 메타데이터 라이프 사이클: UPLOADING → TEMP → ATTACHED → DELETE_PENDING → DELETED

## 4. 개선된 구조의 장점

### 4-1. 데이터 일관성 확보

업로드 후 모든 파일의 존재 여부는 DB 기준으로 판단할 수 있다.
스토리지 파일은 DB의 메타데이터를 통해서만 접근되므로 관리가 명확해진다.

### 4-2. 고아 파일 발생 방지

스토리지 업로드는 항상 "DB 문서 생성 이후"에 실행되므로
스토리지에만 파일이 남는 문제가 구조적으로 사라진다.

### 4-3. 파일 라이프사이클 관리 가능

파일 상태 기반 흐름을 설계할 수 있다:

이를 통해 사용되지 않는 파일 정리, 삭제 로직, 교체 로직 등이 한층 단순해진다.

---

## 5. 개선 후 고려해야 할 점

### 5-1. DB 성공 + 스토리지 실패 케이스 처리

개선된 구조에서는 다음 케이스가 생길 수 있다.

- DB 문서 생성 성공
- 스토리지 업로드 실패

이 경우 UPLOADING 상태의 문서가 남게 되므로 다음 중 하나를 선택해야 한다:

1. 메타데이터 삭제
2. 메타데이터를 `FAILED` 상태로 변경 후 배치나 정리 프로세스에서 처리

### 5-2. 스토리지와 DB는 트랜잭션이 아님

두 시스템을 하나의 트랜잭션으로 묶을 수 없기 때문에
보상 로직(try/catch 내부에서 삭제 또는 FAILED 처리)은 필수 요소다.

---

## 6. 요약

- 기존 구조(스토리지 → DB)는 스토리지에는 존재하지만 DB에는 없는 고아 파일이 생길 수 있는 설계였다.
- 개선된 구조( **DB → 스토리지 → 메타데이터 업데이트** )는 파일을 **DB 기준으로 관리**할 수 있게 만들며 파일의 라이프사이클 관리 및 장애 대응이 쉬워지는 구조다.
